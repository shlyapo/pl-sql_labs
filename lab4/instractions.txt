CREATE OR REPLACE PACKAGE JSON_PARSER IS
    FUNCTION Parse_Arg(l_element JSON_ELEMENT_T) RETURN CLOB;
END JSON_PARSER;

--cursor
CREATE OR REPLACE TYPE clobs_array IS TABLE OF CLOB;

CREATE OR REPLACE FUNCTION DO_PARSE(l_object JSON_OBJECT_T) RETURN clobs_array
    IS
    l_array   json_array_t;
    str_array clobs_array := clobs_array();
    counter   integer;
BEGIN
    IF l_object.has('START') = TRUE THEN
        l_array := l_object.get_array('START');
        FOR counter in 0..(l_array.get_size() - 1)
            LOOP
                str_array.extend();
                str_array(str_array.COUNT) := JSON_PARSER.Parse_Arg(l_array.get(counter));
            END LOOP;
    ELSE
        str_array.extend();
        str_array(str_array.COUNT) := JSON_PARSER.Parse_Arg(l_object);
    END IF;
    return str_array;
END;

CREATE OR REPLACE FUNCTION Get_Cursor_By(l_object JSON_OBJECT_T) RETURN SYS_REFCURSOR
    IS
    res_cur   SYS_REFCURSOR;
    str_array clobs_array;
    counter   integer;
BEGIN
    str_array := DO_PARSE(l_object);
    FOR counter in 1..str_array.COUNT
        LOOP
            OPEN res_cur for str_array(counter);
        END LOOP;
    return res_cur;
END;

CREATE OR REPLACE PROCEDURE Invoke_By(l_object JSON_OBJECT_T)
    IS
    str_array clobs_array;
    counter   integer;
BEGIN
    str_array := DO_PARSE(l_object);
    FOR counter in 1..str_array.COUNT
        LOOP
            EXECUTE IMMEDIATE str_array(counter);
        END LOOP;
END;


CREATE OR REPLACE FUNCTION Try_Get_Cursor_By(l_object JSON_OBJECT_T) RETURN SYS_REFCURSOR
    IS
    res SYS_REFCURSOR;
BEGIN
    res := Get_Cursor_By(l_object);
    return res;
EXCEPTION
    WHEN OTHERS THEN
        Invoke_By(l_object);
        OPEN res FOR
            select * from dual where 1 = 2;
        return res;
END;
CREATE OR REPLACE PACKAGE BODY JSON_PARSER IS

    FUNCTION Parse_Array_Args(l_json_array JSON_ARRAY_T, separator CLOB) RETURN CLOB
        IS
        temp    CLOB;
        res     CLOB    := '';
        isFirst BOOLEAN := TRUE;
        counter integer;
    BEGIN
        FOR counter IN 0 .. (l_json_array.get_size() - 1)
            LOOP
                temp := Parse_Arg(l_json_array.get(counter));
                IF isFirst = TRUE THEN
                    isFirst := FALSE;
                ELSE
                    temp := CONCAT(separator, temp);
                END IF;
                res := CONCAT(res, temp);
            END LOOP;
        return res;
    END;

    FUNCTION Parse_Array_Args(l_json_array JSON_KEY_LIST, separator CLOB) RETURN CLOB
        IS
        temp    CLOB;
        res     CLOB    := '';
        isFirst BOOLEAN := TRUE;
        counter integer;
    BEGIN
        FOR counter IN 1 .. l_json_array.COUNT
            LOOP
                temp := l_json_array(counter);
                IF isFirst = TRUE THEN
                    isFirst := FALSE;
                ELSE
                    temp := CONCAT(separator, temp);
                END IF;
                res := CONCAT(res, temp);
            END LOOP;
        return res;
    END;

    FUNCTION Make_Operation(LHS CLOB, RHS CLOB, operation CLOB) RETURN CLOB
        IS
    BEGIN
        return LHS || ' ' || operation || ' ' || RHS;
    END;

    FUNCTION Get_Operation(l_object JSON_OBJECT_T) RETURN CLOB
        IS
        UNKNOWN_OPERATION EXCEPTION;
        PRAGMA exception_init (UNKNOWN_OPERATION , -20001 );
        ex        VARCHAR2(10) := 'UNKNOWN';
        res       CLOB;
        operation CLOB;
    BEGIN
        operation := UPPER(l_object.get_string('OPERATOR'));
        res := CASE
                   WHEN
                       operation in ('=', '!=', '<>', '<', '>', '>=', '<=')
                       THEN Make_Operation(Parse_Arg(l_object.get('LHS')), Parse_Arg(l_object.get('RHS')), operation)
                   WHEN operation in ('IN', 'NOT IN') THEN Make_Operation(Parse_Arg(l_object.get('LHS')), '(' ||
                                                                                                          Parse_Array_Args(l_object.get_array('RHS'), ', ') ||
                                                                                                          ')',
                                                                          operation)
                   WHEN operation in ('EXISTS', 'NOT EXISTS')
                       THEN operation || ' (' || Parse_Arg(l_object.get('RHS')) || ')'
                   ELSE ex
            END;
        IF res = ex THEN raise_application_error(-20001, 'Unknown operation: ' || operation); END IF;
        return res;
    END;
